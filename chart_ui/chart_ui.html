<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>ES Chart Pro (v5.0)</title>

    <!-- Load library globally -->
    <script src="https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js"></script>

    <!-- Load Plugin Scripts (Modules) -->
    <!-- Note: We load these as modules but they attach to window -->
    <script type="module" src="trendline_plugin.js"></script>
    <script type="module" src="rectangle_plugin.js"></script>
    <script type="module" src="fibonacci_plugin.js"></script>
    <script type="module" src="vertical_line_plugin.js"></script>
    <script type="module" src="anchored_text_plugin.js"></script>

    <!-- Load Indicator Manager -->
    <script src="indicator_manager.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #1e222d;
            color: #d1d4dc;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }

        #toolbar {
            height: 54px;
            background: #2a2e39;
            border-bottom: 1px solid #363c4e;
            display: flex;
            align-items: center;
            padding: 0 16px;
            gap: 16px;
        }

        .toolbar-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        button,
        select,
        input {
            background: #1e222d;
            color: #d1d4dc;
            border: 1px solid #363c4e;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
        }

        button:hover,
        select:hover {
            border-color: #50566e;
        }

        button.active {
            background: #2962FF;
            border-color: #2962FF;
            color: white;
        }

        .divider {
            width: 1px;
            height: 24px;
            background: #363c4e;
            margin: 0 8px;
        }

        #status {
            font-size: 12px;
            color: #787b86;
            margin-left: auto;
        }
    </style>
</head>

<body>
    <div id="toolbar">
        <div class="toolbar-group">
            <h3>ES Chart Pro</h3>
            <div class="divider"></div>

            <!-- Ticker Selection -->
            <select id="tickerSelect" onchange="changeTicker()">
                <option value="ES1" selected>ES1</option>
            </select>

            <!-- Timeframe -->
            <select id="timeframe">
                <option value="1m">1 Min</option>
                <option value="5m">5 Min</option>
                <option value="15m">15 Min</option>
                <option value="1h" selected>1 Hour</option>
                <option value="4h">4 Hours</option>
                <option value="1D">1 Day</option>
            </select>

            <div class="divider"></div>

            <!-- Drawing Tools -->
            <button id="btn-line" onclick="setTool('line')" title="Draw Price Line">üìè Line</button>
            <button id="btn-ray" onclick="setTool('ray')" title="Draw Trend Line">üìâ Trend</button>
            <button id="btn-rect" onclick="setTool('rect')" title="Draw Rectangle">‚ñ≠ Rect</button>
            <button id="btn-fib" onclick="setTool('fib')" title="Draw Fibonacci">üî¢ Fib</button>
            <button id="btn-vert" onclick="setTool('vert')" title="Draw Vertical Line">‚îÇ Vert</button>
            <button id="btn-text" onclick="addWatermark()" title="Add Watermark">T Text</button>
            <button onclick="clearDrawings()" title="Clear All Drawings">üóë</button>

            <div class="divider"></div>

            <!-- Indicators & Strategy -->
            <select id="indicatorSelect" onchange="addIndicatorFromMenu(this)">
                <option value="" disabled selected>+ Indicators</option>
                <option value="sma">SMA (20)</option>
                <option value="ema">EMA (50)</option>
                <option value="vwap">VWAP</option>
                <option value="bb">Bollinger Bands</option>
                <option value="rsi">RSI (14)</option>
                <option value="macd">MACD (12, 26, 9)</option>
                <option value="atr">ATR (14)</option>
            </select>
            <button id="strategyBtn" onclick="toggleStrategy()">‚ö° Strategy</button>
        </div>

        <div class="toolbar-group">
            <!-- Navigation -->
            <input type="date" id="datePicker">
            <button onclick="jumpToDate()">Go</button>

            <div class="divider"></div>

            <!-- Timezone -->
            <select id="timezone">
                <option value="America/New_York" selected>NY (EST)</option>
                <option value="America/Chicago">Chicago (CST)</option>
                <option value="America/Los_Angeles">LA (PST)</option>
                <option value="UTC">UTC</option>
                <option value="Europe/London">London</option>
            </select>

            <div class="divider"></div>
            <div id="status">Loading...</div>
        </div>
    </div>

    <div id="chart-container" style="display: flex; flex-direction: column; height: calc(100vh - 54px);">
        <div id="chart" style="flex: 1; min-height: 400px;"></div>
        <div id="indicator-container" style="flex: 0 0 auto;"></div>
    </div>

    <script>
        // --- Configuration ---
        let currentTimezone = 'America/New_York';
        let currentTimeframe = '1h';
        let currentTicker = 'ES1';
        let currentTool = null;
        let drawings = []; // Stores primitives
        let strategyLines = [];
        let isStrategyActive = false;
        let allData = [];
        let indicatorManager = null;

        // Drawing State
        let activeDrawing = null;
        let startPoint = null; // { time, price }

        // --- Chart Initialization (v5.0) ---
        if (!window.LightweightCharts) {
            document.getElementById('status').textContent = 'Error: Library not loaded.';
            throw new Error('LightweightCharts not found');
        }

        const chart = window.LightweightCharts.createChart(document.getElementById('chart'), {
            autoSize: true,
            layout: { background: { color: '#1e222d' }, textColor: '#d1d4dc' },
            grid: { vertLines: { color: '#2a2e39' }, horzLines: { color: '#2a2e39' } },
            timeScale: { timeVisible: true, rightOffset: 5 },
            crosshair: { mode: window.LightweightCharts.CrosshairMode.Normal },
            localization: {
                timeFormatter: function (timestamp) {
                    const date = new Date(timestamp * 1000);
                    return date.toLocaleString('en-US', {
                        timeZone: currentTimezone,
                        month: 'short', day: 'numeric',
                        hour: '2-digit', minute: '2-digit', hour12: false
                    });
                }
            }
        });

        // Main Series (Candlestick) - v5 Syntax
        const series = chart.addSeries(window.LightweightCharts.CandlestickSeries, {
            upColor: '#26a69a', downColor: '#ef5350',
            wickUpColor: '#26a69a', wickDownColor: '#ef5350'
        });

        // Volume Series - DISABLED per user request
        // const volumeSeries = ...

        // PDH/PDL Lines
        let pdhLine = null;
        let pdlLine = null;

        // --- Data Loading ---
        async function loadTickers() {
            try {
                const response = await fetch('http://localhost:8000/api/tickers');
                const result = await response.json();

                const select = document.getElementById('tickerSelect');
                select.innerHTML = '';

                result.tickers.forEach(ticker => {
                    const option = document.createElement('option');
                    option.value = ticker;
                    option.textContent = ticker;
                    if (ticker === currentTicker) option.selected = true;
                    select.appendChild(option);
                });
            } catch (error) {
                console.error('Failed to load tickers:', error);
            }
        }

        function changeTicker() {
            currentTicker = document.getElementById('tickerSelect').value;
            loadData(currentTimeframe);
        }

        async function loadData(timeframe) {
            document.getElementById('status').textContent = `Loading ${currentTicker}...`;
            try {
                const response = await fetch(`http://localhost:8000/api/ohlc/${timeframe}?limit=20000&ticker=${currentTicker}`);
                const result = await response.json();

                if (!result.data || !Array.isArray(result.data)) {
                    throw new Error('Invalid data format');
                }

                allData = result.data; // Store for navigation
                series.setData(allData);
                // volumeSeries.setData(allData); // DISABLED

                // Calculate PDH/PDL
                calculatePDHPDL(allData);

                chart.timeScale().fitContent();
                document.getElementById('status').textContent = `${currentTicker} - ${allData.length.toLocaleString()} bars`;

                // Re-run strategy if active
                if (isStrategyActive) runStrategy();

                // Reload indicators if any (optional, but good practice)
                if (indicatorManager) {
                    indicatorManager.removeAll();
                }

            } catch (error) {
                console.error(error);
                document.getElementById('status').textContent = 'Error: ' + error.message;
            }
        }

        function calculatePDHPDL(data) {
            if (data.length === 0) return;

            const lastBar = data[data.length - 1];
            const lastDate = new Date(lastBar.time * 1000);
            lastDate.setHours(0, 0, 0, 0);
            const todayStart = Math.floor(lastDate.getTime() / 1000);
            const yesterdayStart = todayStart - 86400;

            const yesterdayBars = data.filter(bar => bar.time >= yesterdayStart && bar.time < todayStart);

            if (pdhLine) series.removePriceLine(pdhLine);
            if (pdlLine) series.removePriceLine(pdlLine);

            if (yesterdayBars.length > 0) {
                const pdh = Math.max(...yesterdayBars.map(b => b.high));
                const pdl = Math.min(...yesterdayBars.map(b => b.low));

                pdhLine = series.createPriceLine({
                    price: pdh, color: '#2962FF', lineWidth: 2, lineStyle: 2,
                    axisLabelVisible: true, title: 'PDH'
                });
                pdlLine = series.createPriceLine({
                    price: pdl, color: '#FF6D00', lineWidth: 2, lineStyle: 2,
                    axisLabelVisible: true, title: 'PDL'
                });
            }
        }

        // --- Drawing Tools ---
        function setTool(tool) {
            currentTool = (currentTool === tool) ? null : tool; // Toggle
            activeDrawing = null;
            startPoint = null;

            // Update UI
            document.querySelectorAll('button').forEach(b => b.classList.remove('active'));
            if (currentTool === 'line') document.getElementById('btn-line').classList.add('active');
            if (currentTool === 'ray') document.getElementById('btn-ray').classList.add('active');
            if (currentTool === 'rect') document.getElementById('btn-rect').classList.add('active');
            if (currentTool === 'fib') document.getElementById('btn-fib').classList.add('active');
            if (currentTool === 'vert') document.getElementById('btn-vert').classList.add('active');

            document.body.style.cursor = currentTool ? 'crosshair' : 'default';

            // Disable chart scrolling while drawing? No, better to keep it.
            chart.applyOptions({ handleScroll: !currentTool, handleScale: !currentTool });
        }

        function clearDrawings() {
            // Remove primitives
            drawings.forEach(d => {
                if (d.detach) d.detach(); // If primitive
                if (series.removePriceLine) try { series.removePriceLine(d); } catch (e) { } // If price line
            });
            drawings = [];
            setTool(null);
        }

        chart.subscribeClick((param) => {
            if (!currentTool || !param.point || !param.time) return;

            const price = series.coordinateToPrice(param.point.y);
            const time = param.time;

            if (currentTool === 'line') {
                // Horizontal Line (Simple)
                const line = series.createPriceLine({
                    price: price, color: '#2962FF', lineWidth: 2, lineStyle: 0,
                    axisLabelVisible: true, title: 'Line'
                });
                drawings.push(line);
                setTool(null);
            }
            else if (currentTool === 'ray') {
                // Trend Line (Diagonal) - 2 Click Process
                if (!startPoint) {
                    // First Click
                    startPoint = { time, price };

                    // Create initial primitive (0 length)
                    if (window.TrendLine) {
                        const tl = new window.TrendLine(chart, series, startPoint, startPoint, { lineColor: '#D500F9', lineWidth: 2 });
                        series.attachPrimitive(tl);
                        activeDrawing = tl;
                        drawings.push(tl);
                    }
                } else {
                    // Second Click - Finish
                    if (activeDrawing) {
                        activeDrawing.updateEnd({ time, price });
                        activeDrawing = null;
                        startPoint = null;
                        setTool(null);
                    }
                }
            }
            else if (currentTool === 'rect') {
                // Rectangle - 2 Click Process
                if (!startPoint) {
                    // First Click
                    startPoint = { time, price };

                    // Create initial primitive
                    if (window.Rectangle) {
                        const rect = new window.Rectangle(chart, series, startPoint, startPoint, {
                            color: 'rgba(33, 150, 243, 0.2)',
                            borderColor: '#2196F3'
                        });
                        series.attachPrimitive(rect);
                        activeDrawing = rect;
                        drawings.push(rect);
                    }
                } else {
                    // Second Click - Finish
                    if (activeDrawing) {
                        activeDrawing.updateEnd({ time, price });
                        activeDrawing = null;
                        startPoint = null;
                        setTool(null);
                    }
                }
            }
            else if (currentTool === 'fib') {
                // Fibonacci - 2 Click Process
                if (!startPoint) {
                    // First Click
                    startPoint = { time, price };

                    if (window.FibonacciRetracement) {
                        const fib = new window.FibonacciRetracement(chart, series, startPoint, startPoint, {
                            lineColor: '#2962FF',
                            labelColor: '#2962FF'
                        });
                        series.attachPrimitive(fib);
                        activeDrawing = fib;
                        drawings.push(fib);
                    }
                } else {
                    // Second Click - Finish
                    if (activeDrawing) {
                        activeDrawing.updateEnd({ time, price });
                        activeDrawing = null;
                        startPoint = null;
                        setTool(null);
                    }
                }
            }
            else if (currentTool === 'vert') {
                // Vertical Line (Simple)
                if (window.VertLine) {
                    const vl = new window.VertLine(chart, series, time, {
                        color: '#00C853',
                        width: 2
                    });
                    series.attachPrimitive(vl);
                    drawings.push(vl);
                    setTool(null); // Finish immediately
                }
            }
        });

        // Mouse Move for Dragging
        document.getElementById('chart').addEventListener('mousemove', (e) => {
            if ((currentTool === 'ray' || currentTool === 'rect' || currentTool === 'fib') && activeDrawing && startPoint) {
                // We need to convert mouse X/Y to Time/Price

                const rect = document.getElementById('chart').getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                const time = chart.timeScale().coordinateToTime(x);
                const price = series.coordinateToPrice(y);

                if (time && price) {
                    activeDrawing.updateEnd({ time, price });
                }
            }
        });

        // --- Navigation ---
        function jumpToDate() {
            const dateStr = document.getElementById('datePicker').value;
            if (!dateStr) return;

            const targetDate = new Date(dateStr).getTime() / 1000;
            // Find closest bar
            const targetIndex = allData.findIndex(d => d.time >= targetDate);

            if (targetIndex !== -1) {
                const range = 100; // Show 100 bars
                const from = Math.max(0, targetIndex - range / 2);
                const to = Math.min(allData.length - 1, targetIndex + range / 2);
                chart.timeScale().setVisibleLogicalRange({ from, to });
            } else {
                alert('Date not found in loaded data');
            }
        }

        // --- Strategy (Demo) ---
        function toggleStrategy() {
            isStrategyActive = !isStrategyActive;
            const btn = document.getElementById('strategyBtn');
            btn.style.background = isStrategyActive ? '#2962FF' : '#1e222d';
            btn.style.color = isStrategyActive ? 'white' : '#d1d4dc';

            if (isStrategyActive) {
                runStrategy();
            } else {
                clearStrategy();
            }
        }

        function runStrategy() {
            clearStrategy();
            // Simple Moving Average Crossover Strategy (SMA 20 vs SMA 50)
            // This is just a visualization, not a real backtest engine here

            // We need to calculate SMAs first. 
            // For simplicity, let's just mark where Price > SMA 20 (Bullish) and Price < SMA 20 (Bearish)
            // Or just random markers for demo if we don't have indicators calculated in JS.

            // Better: Let's use the loaded data to find simple patterns
            // e.g. 3 consecutive green candles

            for (let i = 3; i < allData.length; i++) {
                const c1 = allData[i];
                const c2 = allData[i - 1];
                const c3 = allData[i - 2];

                // 3 Green Soldiers
                if (c1.close > c1.open && c2.close > c2.open && c3.close > c3.open) {
                    const line = series.createPriceLine({
                        price: c1.low,
                        color: '#00E676',
                        lineWidth: 1,
                        lineStyle: 2,
                        axisLabelVisible: false,
                        title: 'Buy'
                    });
                    strategyLines.push(line);
                }
            }
        }

        function clearStrategy() {
            strategyLines.forEach(l => series.removePriceLine(l));
            strategyLines = [];
        }

        // --- Watermark ---
        function addWatermark() {
            if (window.AnchoredText) {
                // Default to center of visible range or last bar
                const lastBar = allData[allData.length - 1];
                if (!lastBar) return;

                const text = new window.AnchoredText(chart, series,
                    { time: lastBar.time, price: lastBar.close },
                    { text: "Watermark", color: "rgba(255, 255, 255, 0.5)", fontSize: 48 }
                );
                series.attachPrimitive(text);
                drawings.push(text);
            }
        }

        // --- Initialization ---
        loadTickers().then(() => {
            loadData(currentTimeframe);
        });

    </script>
</body>

</html>