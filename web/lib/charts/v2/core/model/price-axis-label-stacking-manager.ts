// /src/model/price-axis-label-stacking-manager.ts

import {
	IChartApiBase,
	ISeriesApi,
	SeriesType,
	Coordinate,
	IPriceScaleApi,
} from 'lightweight-charts';
import { LabelDataForStacking, PriceAxisViewRendererOptions } from '../types';

const STACKING_OFFSET_PX = 15; // Vertical offset between stacked labels in pixels
const LABEL_MARGIN_PX = 2; // Additional margin between labels

/**
 * Manages the vertical stacking and collision detection for price axis labels generated by line tools.
 *
 * This utility ensures that multiple labels targeting similar Y-coordinates do not overlap
 * on the price scale by calculating and applying a shifted "fixed coordinate" to the colliding labels.
 * This process runs synchronously during the `BaseLineTool.updateAllViews()` cycle.
 *
 * @typeParam HorzScaleItem - The type of the horizontal scale item.
 */
export class PriceAxisLabelStackingManager<HorzScaleItem> {
	private readonly _chart: IChartApiBase<HorzScaleItem>;
	private readonly _series: ISeriesApi<SeriesType, HorzScaleItem>;
	private readonly _labels: Map<string, LabelDataForStacking> = new Map();

	private _priceAxisRendererOptions: PriceAxisViewRendererOptions | null = null;
	private _currentPriceScale: IPriceScaleApi | null = null;

	/**
	 * Initializes the stacking manager and sets up the default renderer options based on chart and series settings.
	 *
	 * @param chart - The Lightweight Charts chart API instance.
	 * @param series - The primary series API instance.
	 */
	public constructor(
		chart: IChartApiBase<HorzScaleItem>,
		series: ISeriesApi<SeriesType, HorzScaleItem>
	) {
		this._chart = chart;
		this._series = series;
		console.log('[PriceAxisLabelStackingManager] Initializing...');

        // NEW: Initialize _priceAxisRendererOptions in the constructor
        const chartOptions = this._chart.options();
        const layoutOptions = chartOptions.layout;
        const priceScaleOptions = this._series.priceScale().options(); // Get for default price scale

        this._priceAxisRendererOptions = {
            font: `${layoutOptions.fontSize || 12}px ${layoutOptions.fontFamily || 'sans-serif'}`, 
            fontFamily: layoutOptions.fontFamily || 'sans-serif',
            color: layoutOptions.textColor || '#FFFFFF',
            fontSize: layoutOptions.fontSize || 12,

            baselineOffset: 0, 
            borderSize: priceScaleOptions.borderVisible ? 1 : 0,
            paddingBottom: 2, 
            paddingInner: 2,  
            paddingOuter: 2,  
            paddingTop: 2,    
            tickLength: priceScaleOptions.ticksVisible ? 4 : 0,
        };
        console.log('[PriceAxisLabelStackingManager] Initial PriceAxisViewRendererOptions set from chart/series defaults.');
	}

	/**
	 * Converts a Y-coordinate (pixel) to a price value using the current price scale.
	 *
	 * @param coordinate - The Y-coordinate in pixels.
	 * @returns The corresponding price value, or `null` if the price scale is not available.
	 * @private
	 */
    private _coordinateToPrice(coordinate: Coordinate): number | null {
        if (this._currentPriceScale) {
            return this._series.coordinateToPrice(coordinate);
        }
        return null;
    }

	/**
	 * Registers a new label or updates an existing one for collision detection.
	 *
	 * Each label provides its desired coordinate, height, and a callback function for the manager
	 * to apply the final, collision-free coordinate.
	 *
	 * @param labelData - The {@link LabelDataForStacking} object containing the label's required information.
	 * @returns void
	 */
	public registerLabel(labelData: LabelDataForStacking): void {
        const isNew = !this._labels.has(labelData.id);
		this._labels.set(labelData.id, labelData);
        // console.log(`[PALSManager Debug] Label ${isNew ? 'registered' : 'updated'}: ${labelData.id} (Tool: ${labelData.toolId})`);
	}

	/**
	 * Removes a label from the tracking system.
	 *
	 * This is called when a tool is destroyed or when a label becomes structurally invalid/invisible.
	 * It also clears any fixed coordinate that was previously applied to the label.
	 *
	 * @param id - The unique identifier of the label to unregister (e.g., `toolId + '-p' + pointIndex`).
	 * @returns void
	 */
	public unregisterLabel(id: string): void {
		const label = this._labels.get(id);
		if (label) {
			label.setFixedCoordinate(undefined);
			this._labels.delete(id);
            // console.log(`[PALSManager Debug] Label unregistered: ${id}`);
		}
	}

	/**
	 * Updates the rendering options that define the size and padding of price axis labels.
	 *
	 * This information is critical for accurate height calculation during the collision detection process.
	 *
	 * @param options - The new {@link PriceAxisViewRendererOptions} object.
	 * @returns void
	 */	
	public setPriceAxisRendererOptions(options: PriceAxisViewRendererOptions): void {
        // Only update if options are significantly different, or if there's no options yet.
        // Deep comparison is complex, a shallow check or just always overwriting is simpler for now.
		this._priceAxisRendererOptions = options;
        // console.log('[PALSManager Debug] PriceAxisViewRendererOptions updated.');
	}

	/**
	 * Executes the core stacking algorithm.
	 *
	 * 1. Collects all currently active and valid labels.
	 * 2. Sorts them by their original Y-coordinate (top-to-bottom).
	 * 3. Iterates through the sorted list, calculating and applying a new `fixedCoordinate`
	 *    to any label that collides with a previously processed label.
	 *
	 * This method must be called synchronously whenever a tool's position changes to ensure
	 * the labels are correctly positioned before the chart redraws.
	 *
	 * @returns void
	 */	
	public updateStacking(): void {
		if (!this._priceAxisRendererOptions) {
			console.warn('[PALSManager] Cannot update stacking: PriceAxisViewRendererOptions not set. Skipping stacking adjustment.');
			this._labels.forEach(label => label.setFixedCoordinate(undefined));
			return;
		}

		const priceScale = this._series.priceScale();
		if (!priceScale) {
			console.warn('[PALSManager] No price scale available. Skipping stacking adjustment.');
			this._labels.forEach(label => label.setFixedCoordinate(undefined));
			return;
		}
		this._currentPriceScale = priceScale;

		const activeLabels: LabelDataForStacking[] = [];
		this._labels.forEach(label => {
			if (label.isVisible() && isFinite(label.originalCoordinate) && label.height > 0) {
				activeLabels.push(label);
			} else {
				// Ensure invisible/invalid labels have their fixed coord cleared
				label.setFixedCoordinate(undefined);
			}
		});

		//console.log(`--- [PALS DEBUG] Starting Stacking Update for ${activeLabels.length} Active Labels ---`);

		if (activeLabels.length < 2) {
			// For 0 or 1 labels, ensure it has no fixed coordinate so it draws at its original location.
			activeLabels.forEach(label => label.setFixedCoordinate(undefined));
			return;
		}

		// Sort labels by their *original* Y-coordinate (top-most first on screen meaning smallest Coordinate)
		// This ensures we always resolve collisions from top to bottom.
		activeLabels.sort((a, b) => a.originalCoordinate - b.originalCoordinate);

		let lastOccupiedBottomCoord: Coordinate | undefined = undefined;

		for (let i = 0; i < activeLabels.length; i++) {
			const currentLabel = activeLabels[i];

			let newFixedCoord: Coordinate = currentLabel.originalCoordinate;
			const currentLabelHalfHeight = currentLabel.height / 2;

			// Calculate the effective top of the *unadjusted* label's space (its original desired position)
			const currentLabelTop = (currentLabel.originalCoordinate - currentLabelHalfHeight) as Coordinate;

			// *** START DEBUG LOGGING ***
			//console.log(`[PALS LOG] --- Label ${currentLabel.id} [${i}] ---`);
			//console.log(`[PALS LOG] Original Coord (Center Y): ${currentLabel.originalCoordinate.toFixed(2)} | Height: ${currentLabel.height.toFixed(2)}`);
			//console.log(`[PALS LOG] Current Label Top Y: ${currentLabelTop.toFixed(2)}`);
			//console.log(`[PALS LOG] Last Occupied Bottom Y: ${lastOccupiedBottomCoord ? lastOccupiedBottomCoord.toFixed(2) : 'None'}`);
			// *** END DEBUG LOGGING ***


			if (lastOccupiedBottomCoord !== undefined) {
				const collisionThreshold = (lastOccupiedBottomCoord + LABEL_MARGIN_PX) as Coordinate;

				//console.log(`[PALS LOG] Collision Threshold Y: ${collisionThreshold.toFixed(2)}`);

				if (currentLabelTop < collisionThreshold) {
					// *** COLLISION DETECTED ***
					//console.log(`[PALS LOG] *** COLLISION: ${currentLabelTop.toFixed(2)} < ${collisionThreshold.toFixed(2)} ***`);

					const newTop = collisionThreshold;
					newFixedCoord = (newTop + currentLabelHalfHeight) as Coordinate;

					// Log the shift
					//console.log(`[PALS LOG] SHIFTED: New Center Y: ${newFixedCoord.toFixed(2)}`);
				} else {
					// Log no shift
					//console.log(`[PALS LOG] NO COLLISION: ${currentLabelTop.toFixed(2)} >= ${collisionThreshold.toFixed(2)}`);
				}
			}

			// --- Apply and Store Final Coordinate ---
			
			// 1. Set the fixed coordinate on the view (undefined if no shift was needed)
			if (newFixedCoord !== currentLabel.originalCoordinate) {
				currentLabel.setFixedCoordinate(newFixedCoord);
			} else {
				currentLabel.setFixedCoordinate(undefined);
			}

			// 2. Determine the final Y-coordinate that was applied
			// This is either the original Y or the newly shifted Y.
			const finalCenterY = newFixedCoord !== currentLabel.originalCoordinate ? newFixedCoord : currentLabel.originalCoordinate;

			// 3. Update the space reserved for the next label
			lastOccupiedBottomCoord = (finalCenterY + currentLabelHalfHeight) as Coordinate;

			//console.log(`[PALS LOG] FINAL lastOccupiedBottomCoord: ${lastOccupiedBottomCoord.toFixed(2)}`);
		}
		//console.log(`--- [PALS DEBUG] Finished Stacking Update ---`);
	}
}